URL: https://developers.openai.com/codex/rules
Scraped: 2026-02-27T16:31:26.514954+00:00

Rules
Search the Codex docs
Primary navigation
Get started
Overview
Quickstart
Models
Pricing
Libraries
Latest: GPT-5.2
Core concepts
Text generation
Code generation
Images and vision
Audio and speech
Structured output
Function calling
Responses API
Agents
Overview
Build agents
Agent Builder
Node reference
Safety in building agents
Agents SDK
Deploy in your product
ChatKit
Custom theming
Widgets
Actions
Advanced integration
Optimize
Agent evals
Trace grading
Voice agents
Tools
Using tools
Connectors and MCP
Skills
Shell
Web search
Code interpreter
File search and retrieval
File search
Retrieval
More tools
Image generation
Computer use
Local shell tool
Apply patch
Run and scale
Conversation state
Background mode
Streaming
WebSocket mode
Webhooks
File inputs
Context management
Compaction
Counting tokens
Prompt caching
Prompting
Overview
Prompt engineering
Reasoning
Reasoning models
Reasoning best practices
Evaluation
Getting started
Working with evals
Prompt optimizer
External models
Best practices
Realtime API
Overview
Connect
WebRTC
WebSocket
SIP
Usage
Using realtime models
Managing conversations
Webhooks and server-side controls
Managing costs
Realtime transcription
Voice agents
Model optimization
Optimization cycle
Fine-tuning
Supervised fine-tuning
Vision fine-tuning
Direct preference optimization
Reinforcement fine-tuning
RFT use cases
Best practices
Graders
Specialized models
Image generation
Video generation
Text to speech
Speech to text
Deep research
Embeddings
Moderation
Going live
Production best practices
Latency optimization
Overview
Predicted Outputs
Priority processing
Cost optimization
Overview
Batch
Flex processing
Accuracy optimization
Safety
Safety best practices
Safety checks
Cybersecurity checks
Under 18 API Guidance
Legacy APIs
Assistants API
Migration guide
Deep dive
Tools
Resources
Terms and policies
Changelog
Your data
Permissions
Rate limits
Deprecations
MCP for deep research
Developer mode
ChatGPT Actions
Introduction
Getting started
Actions library
Authentication
Production
Data retrieval
Sending files
Getting Started
Overview
Quickstart
Explore
Pricing
Concepts
Prompting
Customization
Multi-agents
Workflows
Models
Cyber Safety
Using Codex
App
Overview
Features
Settings
Review
Automations
Worktrees
Local Environments
Commands
Troubleshooting
IDE Extension
Overview
Features
Settings
IDE Commands
Slash commands
CLI
Overview
Features
Command Line Options
Slash commands
Web
Overview
Environments
Internet Access
Integrations
GitHub
Slack
Linear
Configuration
Config File
Config Basics
Advanced Config
Config Reference
Sample Config
Rules
AGENTS.md
MCP
Skills
Multi-agents
Administration
Authentication
Security
Enterprise
Admin Setup
Governance
Managed configuration
Windows
Automation
Non-interactive Mode
Codex SDK
App Server
MCP Server
GitHub Action
Learn
Videos
Blog
Building frontend UIs with Codex and Figma
Testing Agent Skills Systematically with Evals
View all
Cookbooks
Codex Prompting Guide
Long horizon tasks with Codex
View all
Building AI Teams
Community
Ambassadors
Meetups
Releases
Changelog
Feature Maturity
Open Source
Home
Quickstart
Core Concepts
MCP Apps in ChatGPT
MCP Server
UX principles
UI guidelines
Plan
Research use cases
Define tools
Design components
Build
Set up your server
Build your ChatGPT UI
Authenticate users
Manage state
Monetize your app
Examples
Deploy
Deploy your app
Connect from ChatGPT
Test your integration
Submit your app
Guides
Optimize Metadata
Security & Privacy
Troubleshooting
Resources
Changelog
App submission guidelines
Reference
Home
Guides
Get started
Key concepts
Production readiness
Commerce specs
Agentic Checkout
Delegated Payment
Product feeds
Overview
Onboarding
Feed spec
Best practices
Home
Docs MCP
Categories
Code
Cookbooks
Guides
Videos
Topics
Agents
Audio & Voice
Computer use
Codex
Evals
gpt-oss
Fine-tuning
Image generation
Scaling
Tools
Video generation
Home
Topics
Agents
Evals
Multimodal
Text
Guardrails
Optimization
ChatGPT
Codex
gpt-oss
Contribute
Cookbook on GitHub
All posts
Recent
Building frontend UIs with Codex and Figma
Shell + Skills + Compaction: Tips for long-running agents that do real work
15 lessons learned building ChatGPT Apps
Testing Agent Skills Systematically with Evals
Supercharging Codex with JetBrains MCP at Skyscanner
Topics
General
API
Apps SDK
Audio
Codex
API Dashboard
Use rules to control which commands Codex can run outside the sandbox.
Rules are experimental and may change.
Create a rules file
Create a
.rules
file under
./codex/rules/
(for example,
~/.codex/rules/default.rules
).
Add a rule. This example prompts before allowing
gh pr view
to run outside the sandbox.
# Prompt before running commands with the prefix `gh pr view` outside the sandbox.
prefix_rule(
# The prefix to match.
pattern
=
[
"gh"
,
"pr"
,
"view"
],
# The action to take when Codex requests to run a matching command.
decision
=
"prompt"
,
# Optional rationale for why this rule exists.
justification
=
"Viewing PRs is allowed with approval"
,
# `match` and `not_match` are optional "inline unit tests" where you can
# provide examples of commands that should (or should not) match this rule.
match
=
[
"gh pr view 7888"
,
"gh pr view --repo openai/codex"
,
"gh pr view 7888 --json title,body,comments"
,
],
not_match
=
[
# Does not match because the `pattern` must be an exact prefix.
"gh pr --repo openai/codex view 7888"
,
],
)
Restart Codex.
Codex scans
rules/
under every
Team Config
location at startup. When you add a command to the allow list in the TUI, Codex writes to the user layer at
~/.codex/rules/default.rules
so future runs can skip the prompt.
When Smart approvals are enabled (the default), Codex may propose a
prefix_rule
for you during escalation requests. Review the suggested prefix
carefully before accepting it.
Admins can also enforce restrictive
prefix_rule
entries from
requirements.toml
.
Understand rule fields
prefix_rule()
supports these fields:
pattern
(required)
: A non-empty list that defines the command prefix to match. Each element is either:
A literal string (for example,
"pr"
).
A union of literals (for example,
["view", "list"]
) to match alternatives at that argument position.
decision
(defaults to
"allow"
)
: The action to take when the rule matches. Codex applies the most restrictive decision when more than one rule matches (
forbidden
>
prompt
>
allow
).
allow
: Run the command outside the sandbox without prompting.
prompt
: Prompt before each matching invocation.
forbidden
: Block the request without prompting.
justification
(optional)
: A non-empty, human-readable reason for the rule. Codex may surface it in approval prompts or rejection messages. When you use
forbidden
, include a recommended alternative in the justification when appropriate (for example,
"Use \
rg` instead of `grep`.”`).
match
and
not_match
(defaults to
[]
)
: Examples that Codex validates when it loads your rules. Use these to catch mistakes before a rule takes effect.
When Codex considers a command to run, it compares the command’s argument list to
pattern
. Internally, Codex treats the command as a list of arguments (like what
execvp(3)
receives).
Shell wrappers and compound commands
Some tools wrap several shell commands into a single invocation, for example:
["bash", "-lc", "git add . && rm -rf /"]
Because this kind of command can hide multiple actions inside one string, Codex treats
bash -lc
,
bash -c
, and their
zsh
/
sh
equivalents specially.
When Codex can safely split the script
If the shell script is a linear chain of commands made only of:
plain words (no variable expansion, no
VAR=...
,
$FOO
,
*
, etc.)
joined by safe operators (
&&
,
||
,
;
, or
|
)
then Codex parses it (using tree-sitter) and splits it into individual commands before applying your rules.
The script above is treated as two separate commands:
["git", "add", "."]
["rm", "-rf", "/"]
Codex then evaluates each command against your rules, and the most restrictive result wins.
Even if you allow
pattern=["git", "add"]
, Codex won’t auto allow
git add . && rm -rf /
, because the
rm -rf /
portion is evaluated separately and prevents the whole invocation from being auto allowed.
This prevents dangerous commands from being smuggled in alongside safe ones.
When Codex does not split the script
If the script uses more advanced shell features, such as:
redirection (
>
,
>>
,
<
)
substitutions (
$(...)
,
...
)
environment variables (
FOO=bar
)
wildcard patterns (
*
,
?
)
control flow (
if
,
for
,
&&
with assignments, etc.)
then Codex doesn’t try to interpret or split it.
In those cases, the entire invocation is treated as:
["bash", "-lc", "<full script>"]
and your rules are applied to that
single
invocation.
With this handling, you get the security of per-command evaluation when it’s safe to do so, and conservative behavior when it isn’t.
Test a rule file
Use
codex execpolicy check
to test how your rules apply to a command:
codex
execpolicy
check
--pretty
\
--rules
~/.codex/rules/default.rules
\
--
gh
pr
view
7888
--json
title,body,comments
The command emits JSON showing the strictest decision and any matching rules, including any
justification
values from matched rules. Use more than one
--rules
flag to combine files, and add
--pretty
to format the output.
Understand the rules language
The
.rules
file format uses
Starlark
(see the
language spec
). Its syntax is like Python, but it’s designed to be safe to run: the rules engine can run it without side effects (for example, touching the filesystem).