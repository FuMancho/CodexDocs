URL: https://developers.openai.com/codex/auth
Scraped: 2026-02-27T16:31:31.327982+00:00

Authentication
Search the Codex docs
Primary navigation
Get started
Overview
Quickstart
Models
Pricing
Libraries
Latest: GPT-5.2
Core concepts
Text generation
Code generation
Images and vision
Audio and speech
Structured output
Function calling
Responses API
Agents
Overview
Build agents
Agent Builder
Node reference
Safety in building agents
Agents SDK
Deploy in your product
ChatKit
Custom theming
Widgets
Actions
Advanced integration
Optimize
Agent evals
Trace grading
Voice agents
Tools
Using tools
Connectors and MCP
Skills
Shell
Web search
Code interpreter
File search and retrieval
File search
Retrieval
More tools
Image generation
Computer use
Local shell tool
Apply patch
Run and scale
Conversation state
Background mode
Streaming
WebSocket mode
Webhooks
File inputs
Context management
Compaction
Counting tokens
Prompt caching
Prompting
Overview
Prompt engineering
Reasoning
Reasoning models
Reasoning best practices
Evaluation
Getting started
Working with evals
Prompt optimizer
External models
Best practices
Realtime API
Overview
Connect
WebRTC
WebSocket
SIP
Usage
Using realtime models
Managing conversations
Webhooks and server-side controls
Managing costs
Realtime transcription
Voice agents
Model optimization
Optimization cycle
Fine-tuning
Supervised fine-tuning
Vision fine-tuning
Direct preference optimization
Reinforcement fine-tuning
RFT use cases
Best practices
Graders
Specialized models
Image generation
Video generation
Text to speech
Speech to text
Deep research
Embeddings
Moderation
Going live
Production best practices
Latency optimization
Overview
Predicted Outputs
Priority processing
Cost optimization
Overview
Batch
Flex processing
Accuracy optimization
Safety
Safety best practices
Safety checks
Cybersecurity checks
Under 18 API Guidance
Legacy APIs
Assistants API
Migration guide
Deep dive
Tools
Resources
Terms and policies
Changelog
Your data
Permissions
Rate limits
Deprecations
MCP for deep research
Developer mode
ChatGPT Actions
Introduction
Getting started
Actions library
Authentication
Production
Data retrieval
Sending files
Getting Started
Overview
Quickstart
Explore
Pricing
Concepts
Prompting
Customization
Multi-agents
Workflows
Models
Cyber Safety
Using Codex
App
Overview
Features
Settings
Review
Automations
Worktrees
Local Environments
Commands
Troubleshooting
IDE Extension
Overview
Features
Settings
IDE Commands
Slash commands
CLI
Overview
Features
Command Line Options
Slash commands
Web
Overview
Environments
Internet Access
Integrations
GitHub
Slack
Linear
Configuration
Config File
Config Basics
Advanced Config
Config Reference
Sample Config
Rules
AGENTS.md
MCP
Skills
Multi-agents
Administration
Authentication
Security
Enterprise
Admin Setup
Governance
Managed configuration
Windows
Automation
Non-interactive Mode
Codex SDK
App Server
MCP Server
GitHub Action
Learn
Videos
Blog
Building frontend UIs with Codex and Figma
Testing Agent Skills Systematically with Evals
View all
Cookbooks
Codex Prompting Guide
Long horizon tasks with Codex
View all
Building AI Teams
Community
Ambassadors
Meetups
Releases
Changelog
Feature Maturity
Open Source
Home
Quickstart
Core Concepts
MCP Apps in ChatGPT
MCP Server
UX principles
UI guidelines
Plan
Research use cases
Define tools
Design components
Build
Set up your server
Build your ChatGPT UI
Authenticate users
Manage state
Monetize your app
Examples
Deploy
Deploy your app
Connect from ChatGPT
Test your integration
Submit your app
Guides
Optimize Metadata
Security & Privacy
Troubleshooting
Resources
Changelog
App submission guidelines
Reference
Home
Guides
Get started
Key concepts
Production readiness
Commerce specs
Agentic Checkout
Delegated Payment
Product feeds
Overview
Onboarding
Feed spec
Best practices
Home
Docs MCP
Categories
Code
Cookbooks
Guides
Videos
Topics
Agents
Audio & Voice
Computer use
Codex
Evals
gpt-oss
Fine-tuning
Image generation
Scaling
Tools
Video generation
Home
Topics
Agents
Evals
Multimodal
Text
Guardrails
Optimization
ChatGPT
Codex
gpt-oss
Contribute
Cookbook on GitHub
All posts
Recent
Building frontend UIs with Codex and Figma
Shell + Skills + Compaction: Tips for long-running agents that do real work
15 lessons learned building ChatGPT Apps
Testing Agent Skills Systematically with Evals
Supercharging Codex with JetBrains MCP at Skyscanner
Topics
General
API
Apps SDK
Audio
Codex
API Dashboard
OpenAI authentication
Codex supports two ways to sign in when using OpenAI models:
Sign in with ChatGPT for subscription access
Sign in with an API key for usage-based access
Codex cloud requires signing in with ChatGPT. The Codex CLI and IDE extension support both sign-in methods.
Your sign-in method also determines which admin controls and data-handling policies apply.
With sign in with ChatGPT, Codex usage follows your ChatGPT workspace permissions, RBAC, and ChatGPT Enterprise retention and residency settings
With an API key, usage follows your API organization’s retention and data-sharing settings instead
For the CLI, Sign in with ChatGPT is the default authentication path when no valid session is available.
Sign in with ChatGPT
When you sign in with ChatGPT from the Codex app, CLI, or IDE Extension, Codex opens a browser window for you to complete the login flow. After you sign in, the browser returns an access token to the CLI or IDE extension.
Sign in with an API key
You can also sign in to the Codex app, CLI, or IDE Extension with an API key. Get your API key from the
OpenAI dashboard
.
OpenAI bills API key usage through your OpenAI Platform account at standard API rates. See the
API pricing page
.
Recommendation is to use API key authentication for programmatic Codex CLI workflows (for example CI/CD jobs). Do not expose Codex execution in untrusted or publicly triggerable environments.
Secure your Codex cloud account
Codex cloud interacts directly with your codebase, so it needs stronger security than many other ChatGPT features. Enable multi-factor authentication (MFA).
If you use a social login provider (Google, Microsoft, Apple), you aren’t required to enable MFA on your ChatGPT account, but you can set it up with your social login provider.
For setup instructions, see:
Google
Microsoft
Apple
If you access ChatGPT through single sign-on (SSO), your organization’s SSO administrator should enforce MFA for all users.
If you log in using an email and password, you must set up MFA on your account before accessing Codex cloud.
If your account supports more than one login method and one of them is email and password, you must set up MFA before accessing Codex, even if you sign in another way.
Login caching
When you sign in to the Codex app, CLI, or IDE Extension using either ChatGPT or an API key, Codex caches your login details and reuses them the next time you start the CLI or extension. The CLI and extension share the same cached login details. If you log out from either one, you’ll need to sign in again the next time you start the CLI or extension.
Codex caches login details locally in a plaintext file at
~/.codex/auth.json
or in your OS-specific credential store.
For sign in with ChatGPT sessions, Codex refreshes tokens automatically during use before they expire, so active sessions usually continue without requiring another browser login.
Credential storage
Use
cli_auth_credentials_store
to control where the Codex CLI stores cached credentials:
# file | keyring | auto
cli_auth_credentials_store =
"keyring"
file
stores credentials in
auth.json
under
CODEX_HOME
(defaults to
~/.codex
).
keyring
stores credentials in your operating system credential store.
auto
uses the OS credential store when available, otherwise falls back to
auth.json
.
If you use file-based storage, treat
~/.codex/auth.json
like a password: it
contains access tokens. Don’t commit it, paste it into tickets, or share it in
chat.
Enforce a login method or workspace
In managed environments, admins may restrict how users are allowed to authenticate:
# Only allow ChatGPT login or only allow API key login.
forced_login_method =
"chatgpt"
# or "api"
# When using ChatGPT login, restrict users to a specific workspace.
forced_chatgpt_workspace_id =
"00000000-0000-0000-0000-000000000000"
If the active credentials don’t match the configured restrictions, Codex logs the user out and exits.
These settings are commonly applied via managed configuration rather than per-user setup. See
Managed configuration
.
Login on headless devices
If you are signing in to ChatGPT with the Codex CLI, there are some situations where the browser-based login UI may not work:
You’re running the CLI in a remote or headless environment.
Your local networking configuration blocks the localhost callback Codex uses to return the OAuth token to the CLI after you sign in.
In these situations, prefer device code authentication (beta). In the interactive login UI, choose
Sign in with Device Code
, or run
codex login --device-auth
directly. If device code authentication doesn’t work in your environment, use one of the fallback methods.
Preferred: Device code authentication (beta)
Enable device code login in your ChatGPT security settings (personal account) or ChatGPT workspace permissions (workspace admin).
In the terminal where you’re running Codex, choose one of these options:
In the interactive login UI, select
Sign in with Device Code
.
Run
codex login --device-auth
.
Open the link in your browser, sign in, then enter the one-time code.
If device code login isn’t enabled by the server, Codex falls back to the standard browser-based login flow.
Fallback: Authenticate locally and copy your auth cache
If you can complete the login flow on a machine with a browser, you can copy your cached credentials to the headless machine.
On a machine where you can use the browser-based login flow, run
codex login
.
Confirm the login cache exists at
~/.codex/auth.json
.
Copy
~/.codex/auth.json
to
~/.codex/auth.json
on the headless machine.
Treat
~/.codex/auth.json
like a password: it contains access tokens. Don’t commit it, paste it into tickets, or share it in chat.
If your OS stores credentials in a credential store instead of
~/.codex/auth.json
, this method may not apply. See
Credential storage
for how to configure file-based storage.
Copy to a remote machine over SSH:
ssh
user@remote
'mkdir -p ~/.codex'
scp
~/.codex/auth.json
user@remote:~/.codex/auth.json
Or use a one-liner that avoids
scp
:
ssh
user@remote
'mkdir -p ~/.codex && cat > ~/.codex/auth.json'
<
~/.codex/auth.json
Copy into a Docker container:
# Replace MY_CONTAINER with the name or ID of your container.
CONTAINER_HOME
=
$(
docker
exec
MY_CONTAINER
printenv
HOME
)
docker
exec
MY_CONTAINER
mkdir
-p
"
$CONTAINER_HOME
/.codex"
docker
cp
~/.codex/auth.json
MY_CONTAINER:"
$CONTAINER_HOME
/.codex/auth.json"
Fallback: Forward the localhost callback over SSH
If you can forward ports between your local machine and the remote host, you can use the standard browser-based flow by tunneling Codex’s local callback server (default
localhost:1455
).
From your local machine, start port forwarding:
ssh
-L
1455:localhost:1455
user@remote
In that SSH session, run
codex login
and follow the printed address on your local machine.
Alternative model providers
When you define a
custom model provider
in your configuration file, you can choose one of these authentication methods:
OpenAI authentication
: Set
requires_openai_auth = true
to use OpenAI authentication. You can then sign in with ChatGPT or an API key. This is useful when you access OpenAI models through an LLM proxy server. When
requires_openai_auth = true
, Codex ignores
env_key
.
Environment variable authentication
: Set
env_key = "<ENV_VARIABLE_NAME>"
to use a provider-specific API key from the local environment variable named
<ENV_VARIABLE_NAME>
.
No authentication
: If you don’t set
requires_openai_auth
(or set it to
false
) and you don’t set
env_key
, Codex assumes the provider doesn’t require authentication. This is useful for local models.