URL: https://developers.openai.com/codex/concepts/customization
Scraped: 2026-02-27T16:31:08.294864+00:00

Customization
Search the Codex docs
Primary navigation
Get started
Overview
Quickstart
Models
Pricing
Libraries
Latest: GPT-5.2
Core concepts
Text generation
Code generation
Images and vision
Audio and speech
Structured output
Function calling
Responses API
Agents
Overview
Build agents
Agent Builder
Node reference
Safety in building agents
Agents SDK
Deploy in your product
ChatKit
Custom theming
Widgets
Actions
Advanced integration
Optimize
Agent evals
Trace grading
Voice agents
Tools
Using tools
Connectors and MCP
Skills
Shell
Web search
Code interpreter
File search and retrieval
File search
Retrieval
More tools
Image generation
Computer use
Local shell tool
Apply patch
Run and scale
Conversation state
Background mode
Streaming
WebSocket mode
Webhooks
File inputs
Context management
Compaction
Counting tokens
Prompt caching
Prompting
Overview
Prompt engineering
Reasoning
Reasoning models
Reasoning best practices
Evaluation
Getting started
Working with evals
Prompt optimizer
External models
Best practices
Realtime API
Overview
Connect
WebRTC
WebSocket
SIP
Usage
Using realtime models
Managing conversations
Webhooks and server-side controls
Managing costs
Realtime transcription
Voice agents
Model optimization
Optimization cycle
Fine-tuning
Supervised fine-tuning
Vision fine-tuning
Direct preference optimization
Reinforcement fine-tuning
RFT use cases
Best practices
Graders
Specialized models
Image generation
Video generation
Text to speech
Speech to text
Deep research
Embeddings
Moderation
Going live
Production best practices
Latency optimization
Overview
Predicted Outputs
Priority processing
Cost optimization
Overview
Batch
Flex processing
Accuracy optimization
Safety
Safety best practices
Safety checks
Cybersecurity checks
Under 18 API Guidance
Legacy APIs
Assistants API
Migration guide
Deep dive
Tools
Resources
Terms and policies
Changelog
Your data
Permissions
Rate limits
Deprecations
MCP for deep research
Developer mode
ChatGPT Actions
Introduction
Getting started
Actions library
Authentication
Production
Data retrieval
Sending files
Getting Started
Overview
Quickstart
Explore
Pricing
Concepts
Prompting
Customization
Multi-agents
Workflows
Models
Cyber Safety
Using Codex
App
Overview
Features
Settings
Review
Automations
Worktrees
Local Environments
Commands
Troubleshooting
IDE Extension
Overview
Features
Settings
IDE Commands
Slash commands
CLI
Overview
Features
Command Line Options
Slash commands
Web
Overview
Environments
Internet Access
Integrations
GitHub
Slack
Linear
Configuration
Config File
Config Basics
Advanced Config
Config Reference
Sample Config
Rules
AGENTS.md
MCP
Skills
Multi-agents
Administration
Authentication
Security
Enterprise
Admin Setup
Governance
Managed configuration
Windows
Automation
Non-interactive Mode
Codex SDK
App Server
MCP Server
GitHub Action
Learn
Videos
Blog
Building frontend UIs with Codex and Figma
Testing Agent Skills Systematically with Evals
View all
Cookbooks
Codex Prompting Guide
Long horizon tasks with Codex
View all
Building AI Teams
Community
Ambassadors
Meetups
Releases
Changelog
Feature Maturity
Open Source
Home
Quickstart
Core Concepts
MCP Apps in ChatGPT
MCP Server
UX principles
UI guidelines
Plan
Research use cases
Define tools
Design components
Build
Set up your server
Build your ChatGPT UI
Authenticate users
Manage state
Monetize your app
Examples
Deploy
Deploy your app
Connect from ChatGPT
Test your integration
Submit your app
Guides
Optimize Metadata
Security & Privacy
Troubleshooting
Resources
Changelog
App submission guidelines
Reference
Home
Guides
Get started
Key concepts
Production readiness
Commerce specs
Agentic Checkout
Delegated Payment
Product feeds
Overview
Onboarding
Feed spec
Best practices
Home
Docs MCP
Categories
Code
Cookbooks
Guides
Videos
Topics
Agents
Audio & Voice
Computer use
Codex
Evals
gpt-oss
Fine-tuning
Image generation
Scaling
Tools
Video generation
Home
Topics
Agents
Evals
Multimodal
Text
Guardrails
Optimization
ChatGPT
Codex
gpt-oss
Contribute
Cookbook on GitHub
All posts
Recent
Building frontend UIs with Codex and Figma
Shell + Skills + Compaction: Tips for long-running agents that do real work
15 lessons learned building ChatGPT Apps
Testing Agent Skills Systematically with Evals
Supercharging Codex with JetBrains MCP at Skyscanner
Topics
General
API
Apps SDK
Audio
Codex
API Dashboard
Customization is how you make Codex work the way your team works.
In Codex, customization comes from a few layers that work together:
Project guidance (
AGENTS.md
)
for persistent instructions
Skills
for reusable workflows and domain expertise
MCP
for access to external tools and shared systems
Multi-agents
for delegating work to specialized sub-agents
These are complementary, not competing.
AGENTS.md
shapes behavior, skills package repeatable processes, and
MCP
connects Codex to systems outside the local workspace.
AGENTS Guidance
AGENTS.md
gives Codex durable project guidance that travels with your repository and applies before the agent starts work. Keep it small.
Use it for the rules you want Codex to follow every time in a repo, such as:
Build and test commands
Review expectations
Repo-specific conventions
Directory-specific instructions
When the agent makes incorrect assumptions about your codebase, correct them in
AGENTS.md
and ask the agent to update
AGENTS.md
so the fix persists. Treat it as a feedback loop.
Updating
AGENTS.md
:
Start with only the instructions that matter. Codify recurring review feedback, put guidance in the closest directory where it applies, and tell the agent to update
AGENTS.md
when you correct something so future sessions inherit the fix.
When to update
AGENTS.md
Repeated mistakes
: If the agent makes the same mistake repeatedly, add a rule.
Too much reading
: If it finds the right files but reads too many documents, add routing guidance (which directories/files to prioritize).
Recurring PR feedback
: If you leave the same feedback more than once, codify it.
In GitHub
: In a pull request comment, tag
@codex
with a request (for example,
@codex add this to AGENTS.md
) to delegate the update to a cloud task.
Automate drift checks
: Use
automations
to run recurring checks (for example, daily) that look for guidance gaps and suggest what to add to
AGENTS.md
.
Pair
AGENTS.md
with infrastructure that enforces those rules: pre-commit hooks, linters, and type checkers catch issues before you see them, so the system gets smarter about preventing recurring mistakes.
Codex can load guidance from multiple locations: a global file in your Codex home directory (for you as a developer) and repo-specific files that teams can check in. Files closer to the working directory take precedence.
Use the global file to shape how Codex communicates with you (for example, review style, verbosity, and defaults), and keep repo files focused on team and codebase rules.
~/.codex/
AGENTS.md
Global (for you as a developer)
repo-root/
AGENTS.md
Repo-specific (for your team)
Custom instructions with AGENTS.md
Skills
Skills give Codex reusable capabilities for repeatable workflows.
Skills are often the best fit for reusable workflows because they support richer instructions, scripts, and references while staying reusable across tasks.
Skills are loaded and visible to the agent (at least their metadata), so Codex can discover and choose them implicitly. This keeps rich workflows available without bloating context up front.
A skill is typically a
SKILL.md
file plus optional scripts, references, and assets.
my-skill/
SKILL.md
Required: instructions + metadata
scripts/
Optional: executable code
references/
Optional: documentation
assets/
Optional: templates, resources
The skill directory can include a
scripts/
folder with CLI scripts that Codex invokes as part of the workflow (for example, seed data or run validations). When the workflow needs external systems (issue trackers, design tools, docs servers), pair the skill with
MCP
.
Example
SKILL.md
:
---
name
:
commit
description
:
Stage and commit changes in semantic groups. Use when the user wants to commit, organize commits, or clean up a branch before pushing.
---
1.
Do not run
`git add .`
. Stage files in logical groups by purpose.
2.
Group into separate commits: feat → test → docs → refactor → chore.
3.
Write concise commit messages that match the change scope.
4.
Keep each commit focused and reviewable.
Use skills for:
Repeatable workflows (release steps, review routines, docs updates)
Team-specific expertise
Procedures that need examples, references, or helper scripts
Skills can be global (in your user directory, for you as a developer) or repo-specific (checked into
.agents/skills
, for your team). Put repo skills in
.agents/skills
when the workflow applies to that project; use your user directory for skills you want across all repos.
Layer
Global
Repo
AGENTS
~/.codex/AGENTS.md
AGENTS.md
in repo root or nested dirs
Skills
$HOME/.agents/skills
.agents/skills
in repo
Codex uses progressive disclosure for skills:
It starts with metadata (
name
,
description
) for discovery
It loads
SKILL.md
only when a skill is chosen
It reads references or runs scripts only when needed
Skills can be invoked explicitly, and Codex can also choose them implicitly when the task matches the skill description. Clear skill descriptions improve triggering reliability.
Agent Skills
MCP
MCP (Model Context Protocol) is the standard way to connect Codex to external tools and context providers.
It’s especially useful for remotely hosted systems such as Figma, Linear, Jira, GitHub, or internal knowledge services your team depends on.
Use MCP when Codex needs capabilities that live outside the local repo, such as issue trackers, design tools, browsers, or shared documentation systems.
A useful mental model:
Host
: Codex
Client
: the MCP connection inside Codex
Server
: the external tool or context provider
MCP servers can expose:
Tools
(actions)
Resources
(readable data)
Prompts
(reusable prompt templates)
This separation helps you reason about trust and capability boundaries. Some servers mainly provide context, while others expose powerful actions.
In practice, MCP is often most useful when paired with skills:
A skill defines the workflow and names the MCP tools to use
Model Context Protocol
Multi-agents
You can create different agents with different roles and prompt them to use tools differently. For example, one agent might run specific testing commands and configurations, while another has MCP servers that fetch production logs for debugging. Each sub-agent stays focused and uses the right tools for its job.
Multi-agents concepts
Skills + MCP together
Skills plus MCP is where it all comes together: skills define repeatable workflows, and MCP connects them to external tools and systems.
If a skill depends on MCP, declare that dependency in
agents/openai.yaml
so Codex can install and wire it automatically (see
Agent Skills
).
Next step
Build in this order:
Custom instructions with AGENTS.md
so Codex follows your repo conventions. Add pre-commit hooks and linters to enforce those rules.
Skills
so you never have the same conversation twice. Skills can include a
scripts/
directory with CLI scripts or pair with
MCP
for external systems.
MCP
when workflows need external systems (Linear, JIRA, docs servers, design tools).
Multi-agents
when you’re ready to delegate noisy or specialized tasks to sub-agents.